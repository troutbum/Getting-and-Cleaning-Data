makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached
inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
environment(M1)
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                          # calculate the inverse
imat_cached <- cacheSolve(M1)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                    # verify inverse and cached inversed are the same
test <- mydata %*% imat                         # verify matrix %*% inverse = identity matrix
View(test)
## R Programming - April 2014
## Programming Assignment 2 - Caching the Inverse of a Matrix
##
# In this example we introduce the <<- operator which can be used to assign a
# value to an object in an environment that is different from the current
# environment.
# Below are two functions that are used to create a special object
# that stores a matrix and cache's its inverse.
#
# The first function, makeVector creates a special "vector", which is really a
# list containing a function to:
# - set the matrix
# - get matrix
# - set matrix inverse
# - get matrix inverse
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# The second function calculates the inverse of the object. It checks to see if the inverse
# has already been calculated. Ff not, it calculates the inverse and stores it
# in the object.  Returns a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
# Now use these functions to generate an inverse matrix and cache it. Verify that
# the calculated and cached inverses are identical Verify that the matrix
# multiplied by its inverse is equal to the identity matrix
size <- 10                                       # create test data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
mat <- makeCacheMatrix()                         # create caching data structure
mat
mat$set(mydata)                                  # place data into structure
mat$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(mat)                          # calculate the inverse
imat_cached <- cacheSolve(mat)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                     # verify inverse and cached inversed are the same
test <- mydata %*% imat                          # verify matrix %*% inverse = identity matrix
View(test)
Food_Display_Table <- read.table("~/Downloads/MyFoodapediaData/Food_Display_Table.xml", quote="\"")
View(Food_Display_Table)
Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis.Related_Groups__DRG_ <- read.csv("~/Downloads/Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis-Related_Groups__DRG_.csv")
View(Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis.Related_Groups__DRG_)
R.Version()
install.packages("xlsx")
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile = "./data/NGAP.xlsx", method ="curl")
library(xlsx)
rowIndex <- 18:23
colIndex <- 7:15
dat <- read.xlsx("./data/NGAP.xlsx,sheetIndex=1,colIndex=colIndex,rowIndex=rowIndex")
?read.xlsx
?xlsx
dat <- read.xlsx("./data/NGAP.xlsx, sheetIndex=0 ,colIndex=colIndex, rowIndex=rowIndex")
dat <- read.xlsx("./data/NGAP.xlsx, sheetIndex=1 ,colIndex=colIndex, rowIndex=rowIndex")
install.packages("RMySQL")
install.packages(c("MASS", "swirl"))
install.packages("RMySQL")
setwd("~/CourseraHW/Getting-and-Cleaning-Data/CourseProject")
# download file if it isn't already there
if (!file.exists("getdata-projectfiles-UCI HAR Dataset.zip")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
fileName <- "getdata-projectfiles-UCI HAR Dataset.zip"
download.file(fileUrl, destfile=fileName, method ="curl")
unzip(fileName)
dateDownloaded <- date()
}
# unzip file
# read in variable names
filePath <- "./UCI HAR Dataset/"                                # path set in zipped file
features.txt <- read.table(paste(filePath,
"features.txt",sep=""))
variable.names <- as.character(features.txt[,2])                # column labels for dataset
# create logical vector to extract a subset of columns
contains.mean <- grepl("mean()",variable.names,fixed=TRUE)      # returns logical vector containing "mean()"
contains.std <- grepl("std()",variable.names,fixed=TRUE)        # and "std()"
selected.cols <- contains.mean | contains.std
# initial clean up of variable names
names <- gsub("()","",variable.names,fixed=TRUE)                # finds and replaces bad characters
names <- gsub("-","",names,fixed=TRUE)                          # from dataset
names <- gsub("mean",".Mean",names,fixed=TRUE)
names <- gsub("std",".Std",names,fixed=TRUE)
# read in training measurements (7352 rows)
measurements.train <- read.table(paste(filePath,"train/X_train.txt",sep=""),
col.names=as.character(names))
# read in test measurements (2947 rows)
measurements.test <- read.table(paste(filePath,"test/X_test.txt",sep=""),
col.names=as.character(names))
# extract columns of interest using logical vector
data.train <- measurements.train[,selected.cols == TRUE]
data.test <- measurements.test[,selected.cols == TRUE]
data = rbind(data.train, data.test)                             # combine training and test rows
# subject ID for each observation (30 possible volunteers)
subject.id.train <- read.table(paste(filePath,"train/subject_train.txt",sep=""),
col.names=c("subject.id"))
subject.id.test <- read.table(paste(filePath,"test/subject_test.txt",sep=""),
col.names=c("subject.id"))
subject.id = rbind(subject.id.train, subject.id.test)
# activity ID for each observation
activity.id.train <- read.table(paste(filePath,"train/y_train.txt",sep=""),
col.names=c("id"))
activity.id.test <- read.table(paste(filePath,"test/y_test.txt",sep=""),
col.names=c("id"))
activity.id = rbind(activity.id.train, activity.id.test)
# description labels for the 6 possible activities
activity.labels <- read.table(paste(filePath,"activity_labels.txt",sep=""),
col.names=c("id","activity"))
# join tables to get activity description instead of activity number
library(plyr)
activity = join(activity.id, activity.labels)
# combine dataset with Subject ID and Activity columns
x <- cbind(activity$activity, data )
names(x)[1] <- "activity"                                       # rename added column
y <- cbind(subject.id, x)
# sort dataset by (subject.id, activity)
results <- y[order(y$subject.id, y$activity),]
row.names(results) <- NULL                                      # remove row.names system added column
View(results)
results$subject.id <-factor(results$subject.id)                 # convert subject.id to factor
View(results)
View(results)
View(results)
View(measurements.train)
# download file if it isn't already there
if (!file.exists("getdata-projectfiles-UCI HAR Dataset.zip")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
fileName <- "getdata-projectfiles-UCI HAR Dataset.zip"
download.file(fileUrl, destfile=fileName, method ="curl")
unzip(fileName)
dateDownloaded <- date()
}
# unzip file
# read in variable names
filePath <- "./UCI HAR Dataset/"                                # path set in zipped file
features.txt <- read.table(paste(filePath,
"features.txt",sep=""))
variable.names <- as.character(features.txt[,2])                # column labels for dataset
# create logical vector to extract a subset of columns
contains.mean <- grepl("mean()",variable.names,fixed=TRUE)      # returns logical vector containing "mean()"
contains.std <- grepl("std()",variable.names,fixed=TRUE)        # and "std()"
selected.cols <- contains.mean | contains.std
# initial clean up of variable names
names <- gsub("()","",variable.names,fixed=TRUE)                # finds and replaces bad characters
names <- gsub("-","",names,fixed=TRUE)                          # from dataset
names <- gsub("mean",".Mean",names,fixed=TRUE)
names <- gsub("std",".Std",names,fixed=TRUE)
# read in training measurements (7352 rows)
measurements.train <- read.table(paste(filePath,"train/X_train.txt",sep=""),
col.names=as.character(names))
# read in test measurements (2947 rows)
measurements.test <- read.table(paste(filePath,"test/X_test.txt",sep=""),
col.names=as.character(names))
# extract columns of interest using logical vector
data.train <- measurements.train[,selected.cols == TRUE]
data.test <- measurements.test[,selected.cols == TRUE]
data = rbind(data.train, data.test)                             # combine training and test rows
# subject ID for each observation (30 possible volunteers)
subject.id.train <- read.table(paste(filePath,"train/subject_train.txt",sep=""),
col.names=c("subject.id"))
subject.id.test <- read.table(paste(filePath,"test/subject_test.txt",sep=""),
col.names=c("subject.id"))
subject.id = rbind(subject.id.train, subject.id.test)
# activity ID for each observation
activity.id.train <- read.table(paste(filePath,"train/y_train.txt",sep=""),
col.names=c("id"))
activity.id.test <- read.table(paste(filePath,"test/y_test.txt",sep=""),
col.names=c("id"))
activity.id = rbind(activity.id.train, activity.id.test)
# description labels for the 6 possible activities
activity.labels <- read.table(paste(filePath,"activity_labels.txt",sep=""),
col.names=c("id","activity"))
# join tables to get activity description instead of activity number
library(plyr)
activity = join(activity.id, activity.labels)
# combine dataset with Subject ID and Activity columns
x <- cbind(activity$activity, data )
names(x)[1] <- "activity"                                       # rename added column
y <- cbind(subject.id, x)
# sort dataset by (subject.id, activity)
results <- y[order(y$subject.id, y$activity),]
row.names(results) <- NULL                                      # remove row.names system added column
results$subject.id <-factor(results$subject.id)                 # convert subject.id to factor
t1 <- tapply(results,results$subject.id,mean)
f<-results$subject.id
t1 <- tapply(results,f,mean)
t1 <- tapply(results,f,mean())
t1 <- tapply(results,f,mean(,:))
t1 <- tapply(results(,:),f,mean)
f
mtcars
aggdata <-aggregate(results, by=list(subject.id,activity),
FUN=mean, na.rm=TRUE)
aggdata <-aggregate(results, by=list(results$subject.id), FUN=mean)
View(aggdata)
aggdata <-aggregate(results, by=list(results$subject.id, results$activity), FUN=mean)
warning()
View(aggdata)
?aggregate
aggdata <-aggregate(results, by=list(results$activity,results$subject.id), FUN=mean)
View(aggdata)
library(reshape)
install.packages("reshape")
mresults <- melt(results, id=c("subject.id","activity"))
library(reshape)
mresults <- melt(results, id=c("subject.id","activity"))
View(mresults)
View(aggdata)
subjmeans <- cast(mresults, subject.id~variable, mean)
View(subjmeans)
activity.means <- cast(mresults, activity~variable, mean)
View(activity.means)
View(activity.means)
View(subjmeans)
View(results)
library("stringr", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
aggdata <-aggregate(results, by=list(results$subject.id,results$activity), FUN=mean)
View(aggdata)
?aggregate
names(aggdata)
aggdata <-aggregate(results, by=list(subject.id=results$subject.id,activity=results$activity), FUN=mean)
View(aggdata)
aggdata <-aggregate(results, by=list(subject.id=results$subject.id,
activity=results$activity), FUN=mean, na.rm=TRUE)
View(aggdata)
aggdata <-aggregate(results, list(results$subject.id,results$activity), FUN=mean)
View(aggdata)
aggdata <-aggregate(results, by=list(subject.id=results$subject.id,
activity=results$activity), FUN=mean, na.rm=TRUE)
View(aggdata)
aggdata <-aggregate(results, by=list(subject.id=results$subject.id,
activity=results$activity), FUN=mean, na.rm=TRUE, simplify = TRUE)
View(aggdata)
aggdata <-aggregate(results, by=list(subject.id=results$subject.id,
activity=results$activity), FUN=mean, na.rm=TRUE, na.action = na.omit)
View(aggdata)
View(aggdata)
aggdata[,subject.id:=NULL]
aggdata[,activity:=NULL]
aggdata[,aggdata$activity:=NULL]
install.packages("data.table")
aggdata[,subject.id:=NULL]
library(data.table)
aggdata[,subject.id:=NULL]
aggdata[,3:=NULL]
is.data.table(aggdata)
names(aggdata)
aggdata <-aggregate(results, by=list(results$subject.id,results$activity), FUN=mean)
View(aggdata)
aggie <- subset(aggdata,, -c(aggdata$activity))
aggie <- subset(aggdata,,-c(activity))
View(aggie)
aggie <- subset(aggdata,,-c(subject.id, activity))
View(aggie)
names(aggie)
names(Group.1)
View(aggie)
aggdata <-aggregate(results, by=list(results$subject.id,results$activity), FUN=mean)
aggie <- subset(aggdata,,-c(subject.id, activity))
names(aggie)[1] <- "subject.id"
names(aggie)[2] <- "activity"
View(aggie)
aggdata <-aggregate(results, by=list(results$subject.id,results$activity), FUN=mean)
aggdata <- subset(aggdata,,-c(subject.id, activity))
names(aggdata)[1] <- "subject.id"
names(aggdata)[2] <- "activity"
View(aggdata)
# download file if it isn't already there
if (!file.exists("getdata-projectfiles-UCI HAR Dataset.zip")) {
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
fileName <- "getdata-projectfiles-UCI HAR Dataset.zip"
download.file(fileUrl, destfile=fileName, method ="curl")
unzip(fileName)
dateDownloaded <- date()
}
# unzip file
# read in variable names
filePath <- "./UCI HAR Dataset/"                                # path set in zipped file
features.txt <- read.table(paste(filePath,
"features.txt",sep=""))
variable.names <- as.character(features.txt[,2])                # column labels for dataset
# create logical vector to extract a subset of columns
contains.mean <- grepl("mean()",variable.names,fixed=TRUE)      # returns logical vector containing "mean()"
contains.std <- grepl("std()",variable.names,fixed=TRUE)        # and "std()"
selected.cols <- contains.mean | contains.std
# initial clean up of variable names
names <- gsub("()","",variable.names,fixed=TRUE)                # finds and replaces bad characters
names <- gsub("-","",names,fixed=TRUE)                          # from dataset
names <- gsub("mean",".Mean",names,fixed=TRUE)
names <- gsub("std",".Std",names,fixed=TRUE)
# read in training measurements (7352 rows)
measurements.train <- read.table(paste(filePath,"train/X_train.txt",sep=""),
col.names=as.character(names))
# read in test measurements (2947 rows)
measurements.test <- read.table(paste(filePath,"test/X_test.txt",sep=""),
col.names=as.character(names))
# extract columns of interest using logical vector
data.train <- measurements.train[,selected.cols == TRUE]
data.test <- measurements.test[,selected.cols == TRUE]
data = rbind(data.train, data.test)                             # combine training and test rows
# subject ID for each observation (30 possible volunteers)
subject.id.train <- read.table(paste(filePath,"train/subject_train.txt",sep=""),
col.names=c("subject.id"))
subject.id.test <- read.table(paste(filePath,"test/subject_test.txt",sep=""),
col.names=c("subject.id"))
subject.id = rbind(subject.id.train, subject.id.test)
# activity ID for each observation
activity.id.train <- read.table(paste(filePath,"train/y_train.txt",sep=""),
col.names=c("id"))
activity.id.test <- read.table(paste(filePath,"test/y_test.txt",sep=""),
col.names=c("id"))
activity.id = rbind(activity.id.train, activity.id.test)
# description labels for the 6 possible activities
activity.labels <- read.table(paste(filePath,"activity_labels.txt",sep=""),
col.names=c("id","activity"))
# join tables to get activity description instead of activity number
library(plyr)
activity = join(activity.id, activity.labels)
# combine dataset with Subject ID and Activity columns
x <- cbind(activity$activity, data )
names(x)[1] <- "activity"                                       # rename added column
y <- cbind(subject.id, x)
# sort dataset by (subject.id, activity)
results <- y[order(y$subject.id, y$activity),]
row.names(results) <- NULL                                      # remove row.names system added column
# convert subject.id to factor
# results$subject.id <-factor(results$subject.id)                 # convert subject.id to factor
# create "second tidy dataset" that calculates
# average of each variable by subject and activity
#
aggdata <-aggregate(results, by=list(results$subject.id,results$activity), FUN=mean)
aggdata <- subset(aggdata,,-c(subject.id, activity))
names(aggdata)[1] <- "subject.id"
names(aggdata)[2] <- "activity"
View(aggdata)
library(reshape)
mresults <- melt(results, id=c("subject.id","activity"))
subject.means <- cast(mresults, subject.id~variable, mean)
activity.means <- cast(mresults, activity~variable, mean)
View(subject.means)
View(activity.means)
