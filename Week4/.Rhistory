makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached
inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
environment(M1)
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                          # calculate the inverse
imat_cached <- cacheSolve(M1)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                    # verify inverse and cached inversed are the same
test <- mydata %*% imat                         # verify matrix %*% inverse = identity matrix
View(test)
## R Programming - April 2014
## Programming Assignment 2 - Caching the Inverse of a Matrix
##
# In this example we introduce the <<- operator which can be used to assign a
# value to an object in an environment that is different from the current
# environment.
# Below are two functions that are used to create a special object
# that stores a matrix and cache's its inverse.
#
# The first function, makeVector creates a special "vector", which is really a
# list containing a function to:
# - set the matrix
# - get matrix
# - set matrix inverse
# - get matrix inverse
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# The second function calculates the inverse of the object. It checks to see if the inverse
# has already been calculated. Ff not, it calculates the inverse and stores it
# in the object.  Returns a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
# Now use these functions to generate an inverse matrix and cache it. Verify that
# the calculated and cached inverses are identical Verify that the matrix
# multiplied by its inverse is equal to the identity matrix
size <- 10                                       # create test data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
mat <- makeCacheMatrix()                         # create caching data structure
mat
mat$set(mydata)                                  # place data into structure
mat$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(mat)                          # calculate the inverse
imat_cached <- cacheSolve(mat)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                     # verify inverse and cached inversed are the same
test <- mydata %*% imat                          # verify matrix %*% inverse = identity matrix
View(test)
Food_Display_Table <- read.table("~/Downloads/MyFoodapediaData/Food_Display_Table.xml", quote="\"")
View(Food_Display_Table)
Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis.Related_Groups__DRG_ <- read.csv("~/Downloads/Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis-Related_Groups__DRG_.csv")
View(Inpatient_Prospective_Payment_System__IPPS__Provider_Summary_for_the_Top_100_Diagnosis.Related_Groups__DRG_)
R.Version()
install.packages("xlsx")
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile = "./data/NGAP.xlsx", method ="curl")
library(xlsx)
rowIndex <- 18:23
colIndex <- 7:15
dat <- read.xlsx("./data/NGAP.xlsx,sheetIndex=1,colIndex=colIndex,rowIndex=rowIndex")
?read.xlsx
?xlsx
dat <- read.xlsx("./data/NGAP.xlsx, sheetIndex=0 ,colIndex=colIndex, rowIndex=rowIndex")
dat <- read.xlsx("./data/NGAP.xlsx, sheetIndex=1 ,colIndex=colIndex, rowIndex=rowIndex")
install.packages("RMySQL")
install.packages(c("MASS", "swirl"))
install.packages("RMySQL")
setwd("~/CourseraHW/Getting-and-Cleaning-Data/Week4")
strsplit("a.b.c", "[.]"))
strsplit("a.b.c", "[.]")
s <-c("a.b.c")
s
strsplit(s,"[.]")
unlist(strsplit(s,"[.]"))
# Getting and Cleaning Data
# May 2014
# Quiz 4
# Question 1
# The American Community Survey distributes downloadable data about United
# States communities. Download the 2006 microdata survey about housing for the
# state of Idaho using download.file() from here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv
#
# and load the data into R. The code book, describing the variable names is here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf
#
# Apply strsplit() to split all the names of the data frame on the characters
# "wgtp". What is the value of the 123 element of the resulting list?
# "wgtp"
# "w" "15"
# "" "15"
# "wgt" "15"
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download code book
fileName <- "getdata-data-PUMSDataDict06.pdf"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# download dataset
fileName <- "getdata-data-ss06hid.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# read in dataset
x <- read.csv(xFile)
xnames <- names(x)
xsplit <- strsplit(xnames, wgtp)
# subset DFs to just CountryCode vectors for comparison
e <-as.character(ED[,1])
g <-as.character(GDP[,1])
# how many empty elements
summary(!(e %in% c("")))
summary(!(g %in% c("")))
# strip out empty elements
g <- g[g != ""]
summary(!(g %in% c("")))
# compare intersection of these vectors
matches <- intersect(e,g)
str(matches)
# subset GDP to observations with Rank (190 observations)
gg <- GDP[1:190,]
matches2 <- intersect(e,gg[,1])
str(matches2)
x[3]
y <- x[3]
z <- x[[3]]
z <- x[[2]]
z <- x[[1]]
z <- x[[4]]
View(x)
z <- x[2]
str(z)
z <- x[[2]]
str(z)
z <- x[[PUMA]]
z <- x[PUMA]
z <- x[x$PUMA]
z <- x[[x$PUMA]]
z <- x[["PUMA"]]
z <- x["PUMA"]
x$PUMA
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download code book
fileName <- "getdata-data-PUMSDataDict06.pdf"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# download dataset
fileName <- "getdata-data-ss06hid.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
x <- read.csv(xFile)
xnames <- names(x)
xsplit <- strsplit(xnames, wgtp)
xsplit <- strsplit(xnames, "wgtp")
xsplit[123]
View(x)
z <- x[123]
View(z)
# Getting and Cleaning Data
# May 2014
# Quiz 4
# Question 1
# The American Community Survey distributes downloadable data about United
# States communities. Download the 2006 microdata survey about housing for the
# state of Idaho using download.file() from here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv
#
# and load the data into R. The code book, describing the variable names is here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf
#
# Apply strsplit() to split all the names of the data frame on the characters
# "wgtp". What is the value of the 123 element of the resulting list?
# "wgtp"
# "w" "15"
# "" "15"
# "wgt" "15"
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download code book
fileName <- "getdata-data-PUMSDataDict06.pdf"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# download dataset
fileName <- "getdata-data-ss06hid.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# read in dataset
x <- read.csv(xFile)
# split string of names vector
xnames <- names(x)
xsplit <- strsplit(xnames, "wgtp")
xsplit[123]
# inspect
z <- x[123]
View(z)
# Getting and Cleaning Data
# May 2014
# Quiz 4
# Question 1
# The American Community Survey distributes downloadable data about United
# States communities. Download the 2006 microdata survey about housing for the
# state of Idaho using download.file() from here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv
#
# and load the data into R. The code book, describing the variable names is here:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf
#
# Apply strsplit() to split all the names of the data frame on the characters
# "wgtp". What is the value of the 123 element of the resulting list?
# "wgtp"
# "w" "15"
# "" "15"
# "wgt" "15"
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download code book
fileName <- "getdata-data-PUMSDataDict06.pdf"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FPUMSDataDict06.pdf"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# download dataset
fileName <- "getdata-data-ss06hid.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# read in dataset
x <- read.csv(xFile)
# split string of names vector
xnames <- names(x)
xsplit <- strsplit(xnames, "wgtp")
xsplit[123]
# inspect
z <- x[123]
View(z)
strsplt(names(x$wgtp15), "wgtp")
strsplit(names(x$wgtp15), "wgtp")
strsplit(names(x$wgtp15), "wgtp")
names(x$wgtp15)
names(x$123)
names(x[123])
strsplit(names(x[123]), "wgtp")
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download dataset
fileName <- "getdata-data-GDP.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
# read in dataset
x <- read.csv(xFile)
View(x)
x <- read.csv(xFile, stringsAsFactors=FALSE)
x <- read.csv(xFile, stringsAsFactors=FALSE)
View(x)
str(x)
x$2
x[2]
ranks <- as.integer(x[2])
str(x)
ranks <- as.numeric(x[2])
headset <- read.csv(xFile, header = TRUE, nrows = 10)
View(headset)
classes <- sapply(headset, class)
classes[names(classes) %in% c("time")] <- "character"
str(classes)
classses(2)
classses[2]
View(headset)
View(headset)
View(headset)
View(x)
x <- read.csv(xFile, colClasses=c("character","integer","character",
"character","numeric",rep("character",5))
x <- read.csv(xFile, colClasses=c("character","integer","character",
"character","numeric",rep("character",5)))
x <- read.csv(xFile, stringsAsFactors=FALSE)
View(x)
x <- read.csv(xFile, stringsAsFactors=FALSE,skip=4)
View(x)
x <- read.csv(xFile, stringsAsFactors=FALSE,skip=4,nrows=190)
View(x)
View(x)
View(headset)
x <- read.csv(xFile, colClasses=c("character","integer","character",
"character",as.numeric,rep("character",5)))
x$X.4
data <- read.csv(xFile, stringsAsFactors=FALSE,skip=4,nrows=190)
data$X.4 <- gsub("[,]", "", data$X.4)
data <- read.csv(xFile, stringsAsFactors=FALSE,skip=4,nrows=190)
data$X.4 <- as.numeric(gsub("[,]", "", data$X.4))
mean(data$X.4)
View(data)
summary(data$X.4)
# Getting and Cleaning Data
# May 2014
# Quiz 4
# Question 2
# Load the Gross Domestic Product data for the 190 ranked countries in this data set:
#
#         https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv
#
# Remove the commas from the GDP numbers in millions of dollars and average them. What is the average?
#
# Original data sources: http://data.worldbank.org/data-catalog/GDP-ranking-table
# 387854.4
# 293700.3
# 377652.4
# 381668.9
# create a data subdirectory if it does not exist
if (!file.exists("data")) {
dir.create("data")
}
filePath <- "./data/"
# download dataset
fileName <- "getdata-data-GDP.csv"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
xFile <- paste0(filePath, fileName)
if (!file.exists(xFile)) {
download.file(fileUrl, destfile = xFile, method ="curl")
dateDownloaded <- date()
}
x
#
# Big problems in Quiz 3 with mixed datatypes in columns
# (Need to prevent creation of factor levels)
# Method 1
data <- read.csv(xFile, stringsAsFactors=FALSE,skip=4,nrows=190)
data$X.4 <- as.numeric(gsub("[,]", "", data$X.4))                       # cleanup column
mean(data$X.4)
summary(data$X.4)
# Method 2
# not yet worked out
#
# data <- read.csv(xFile, colClasses=c("character","integer","character",
#                                   "character","numeric",rep("character",5)))
#
# headset <- read.csv(xFile, header = TRUE, nrows = 10)           # sample data
# classes <- sapply(headset, class)
# classes[names(classes) %in% c("time")] <- "character"           # issue
# dataset <- read.csv(fname, header = TRUE, colClasses = classes)
View(data)
